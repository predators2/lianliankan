<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>海洋药物连连看 - 游戏</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&family=Noto+Serif+SC:wght@400;700&family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans SC', sans-serif;
            background: linear-gradient(135deg, #1a365d 0%, #2d3748 50%, #1a202c 100%);
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        .game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .game-header {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            z-index: 100;
        }
        
        .game-board {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: pointer;
        }
        
        .score-display {
            font-size: 1.5rem;
            font-weight: bold;
            color: #38b2ac;
        }
        
        .timer-display {
            font-size: 1.2rem;
            color: #ed8936;
        }
        
        .level-display {
            font-size: 1.1rem;
            color: #f6ad55;
        }
        
        .control-btn {
            background: linear-gradient(45deg, #38b2ac, #319795);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 0 0.5rem;
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(56, 178, 172, 0.4);
        }
        
        .pause-btn {
            background: linear-gradient(45deg, #ed8936, #f6ad55);
        }
        
        .pause-btn:hover {
            box-shadow: 0 5px 15px rgba(237, 137, 54, 0.4);
        }
        
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        .pause-menu {
            background: white;
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }
        
        .combo-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #38b2ac;
            pointer-events: none;
            z-index: 150;
            opacity: 0;
        }
        
        .particle-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }
        
        .hint-btn {
            background: linear-gradient(45deg, #805ad5, #9f7aea);
        }
        
        .hint-btn:hover {
            box-shadow: 0 5px 15px rgba(128, 90, 213, 0.4);
        }
        
        .progress-bar {
            width: 200px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #38b2ac, #f6ad55);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- 游戏头部 -->
        <div class="game-header">
            <div class="flex items-center space-x-6">
                <div class="score-display">
                    <span class="text-sm">得分:</span>
                    <span id="score">0</span>
                </div>
                <div class="level-display">
                    <span class="text-sm">关卡:</span>
                    <span id="level">1</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            
            <div class="flex items-center space-x-4">
                <div class="timer-display">
                    <span class="text-sm">时间:</span>
                    <span id="timer">180</span>s
                </div>
                <button class="control-btn hint-btn" onclick="useHint()" id="hintBtn">
                    💡 提示
                </button>
                <button class="control-btn pause-btn" onclick="togglePause()" id="pauseBtn">
                    ⏸️ 暂停
                </button>
                <button class="control-btn" onclick="restartGame()">
                    🔄 重开
                </button>
                <button class="control-btn" onclick="backToHome()">
                    🏠 主页
                </button>
            </div>
        </div>
        
        <!-- 游戏区域 -->
        <div class="game-board">
            <canvas id="gameCanvas"></canvas>
            
            <!-- 粒子效果容器 -->
            <div class="particle-container" id="particleContainer"></div>
            
            <!-- 连击显示 -->
            <div class="combo-display" id="comboDisplay">Perfect!</div>
            
            <!-- 游戏暂停菜单 -->
            <div class="game-overlay" id="gameOverlay">
                <div class="pause-menu">
                    <h2 class="text-3xl font-bold text-gray-800 mb-6">游戏暂停</h2>
                    <div class="space-y-4">
                        <button class="control-btn w-full" onclick="togglePause()">
                            ▶️ 继续游戏
                        </button>
                        <button class="control-btn w-full" onclick="restartGame()">
                            🔄 重新开始
                        </button>
                        <button class="control-btn w-full" onclick="backToHome()">
                            🏠 返回主页
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // 游戏配置
        const GAME_CONFIG = {
            cardWidth: 120,
            cardHeight: 80,
            cardMargin: 15,
            cols: 8,
            rows: 6,
            levelTime: 180, // 3分钟
            hintCost: 50, // 提示消耗分数
            comboBonus: [1, 1.2, 1.5, 2, 2.5, 3] // 连击加成
        };
        
        // 海洋药物数据
        const DRUG_DATA = [
            {
                name: "河豚毒素",
                source: "河豚鱼卵巢",
                structure: "C11H17N3O8",
                effect: "神经镇痛",
                description: "强效的神经毒素，具有抗癌和戒毒作用"
            },
            {
                name: "石房蛤毒素",
                source: "赤潮双鞭毛藻",
                structure: "C10H17N7O4",
                effect: "抗癌研究",
                description: "神经毒素，用于抗癌药物研究"
            },
            {
                name: "沙海葵毒素",
                source: "海葵P.toxica",
                structure: "C129H223N3O54",
                effect: "抗肿瘤",
                description: "最强的冠状动脉收缩剂之一"
            },
            {
                name: "西加毒素",
                source: "岗比甲藻",
                structure: "C60H80O19",
                effect: "神经研究",
                description: "热带鱼类毒素，神经科学研究"
            },
            {
                name: "头孢菌素C",
                source: "海洋真菌",
                structure: "C16H21N3O8S",
                effect: "抗菌消炎",
                description: "广谱抗生素，抗菌作用强"
            },
            {
                name: "藻酸双酯钠",
                source: "褐藻提取物",
                structure: "C6H9NaO7",
                effect: "抗凝血",
                description: "心脑血管疾病防治药物"
            }
        ];
        
        // 游戏状态
        let gameState = {
            score: 0,
            level: 1,
            timeLeft: GAME_CONFIG.levelTime,
            isPaused: false,
            isGameOver: false,
            selectedCards: [],
            matchedPairs: [],
            combo: 0,
            hints: 3,
            cards: [],
            connections: []
        };
        
        // Canvas和游戏上下文
        let canvas, ctx;
        let animationId;
        let timerInterval;
        
        // 初始化游戏
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // 设置Canvas尺寸
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // 初始化卡片
            initCards();
            
            // 设置事件监听
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            
            // 开始游戏循环
            startGameLoop();
            
            // 开始计时
            startTimer();
            
            // 更新UI
            updateUI();
        }
        
        // 调整Canvas尺寸
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            // 重新计算卡片位置
            if (gameState.cards.length > 0) {
                calculateCardPositions();
            }
        }
        
        // 初始化卡片
        function initCards() {
            gameState.cards = [];
            
            // 为每种药物创建4张卡片（名称、来源、结构、功效）
            DRUG_DATA.forEach((drug, drugIndex) => {
                const cards = [
                    { type: 'name', content: drug.name, drugId: drugIndex, id: `name_${drugIndex}` },
                    { type: 'source', content: drug.source, drugId: drugIndex, id: `source_${drugIndex}` },
                    { type: 'structure', content: drug.structure, drugId: drugIndex, id: `structure_${drugIndex}` },
                    { type: 'effect', content: drug.effect, drugId: drugIndex, id: `effect_${drugIndex}` }
                ];
                gameState.cards.push(...cards);
            });
            
            // 随机打乱卡片
            shuffleArray(gameState.cards);
            
            // 计算卡片位置
            calculateCardPositions();
        }
        
        // 计算卡片位置
        function calculateCardPositions() {
            const startX = (canvas.width - (GAME_CONFIG.cols * (GAME_CONFIG.cardWidth + GAME_CONFIG.cardMargin) - GAME_CONFIG.cardMargin)) / 2;
            const startY = (canvas.height - (GAME_CONFIG.rows * (GAME_CONFIG.cardHeight + GAME_CONFIG.cardMargin) - GAME_CONFIG.cardMargin)) / 2;
            
            gameState.cards.forEach((card, index) => {
                const col = index % GAME_CONFIG.cols;
                const row = Math.floor(index / GAME_CONFIG.cols);
                
                card.x = startX + col * (GAME_CONFIG.cardWidth + GAME_CONFIG.cardMargin);
                card.y = startY + row * (GAME_CONFIG.cardHeight + GAME_CONFIG.cardMargin);
                card.width = GAME_CONFIG.cardWidth;
                card.height = GAME_CONFIG.cardHeight;
                card.isVisible = true;
                card.isSelected = false;
                card.isMatched = false;
                card.animationOffset = 0;
            });
        }
        
        // 处理Canvas点击事件
        function handleCanvasClick(event) {
            if (gameState.isPaused || gameState.isGameOver) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // 查找点击的卡片
            const clickedCard = gameState.cards.find(card => 
                card.isVisible && 
                x >= card.x && x <= card.x + card.width &&
                y >= card.y && y <= card.y + card.height
            );
            
            if (clickedCard && !clickedCard.isMatched) {
                selectCard(clickedCard);
            }
        }
        
        // 处理Canvas鼠标移动
        function handleCanvasMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // 检查是否悬停在卡片上
            const hoveredCard = gameState.cards.find(card => 
                card.isVisible && 
                x >= card.x && x <= card.x + card.width &&
                y >= card.y && y <= card.y + card.height
            );
            
            canvas.style.cursor = hoveredCard && !hoveredCard.isMatched ? 'pointer' : 'default';
        }
        
        // 选择卡片
        function selectCard(card) {
            if (gameState.selectedCards.includes(card)) {
                // 取消选择
                card.isSelected = false;
                gameState.selectedCards = gameState.selectedCards.filter(c => c !== card);
            } else if (gameState.selectedCards.length < 4) {
                // 选择卡片
                card.isSelected = true;
                gameState.selectedCards.push(card);
                
                // 播放选择音效
                playSound('select');
                
                // 检查是否选择了4张卡片
                if (gameState.selectedCards.length === 4) {
                    setTimeout(() => checkMatch(), 300);
                }
            }
        }
        
        // 检查匹配
        function checkMatch() {
            const selected = gameState.selectedCards;
            
            // 检查是否来自同一种药物
            const drugIds = selected.map(card => card.drugId);
            const isSameDrug = drugIds.every(id => id === drugIds[0]);
            
            // 检查是否包含所有4种类型
            const types = selected.map(card => card.type);
            const hasAllTypes = ['name', 'source', 'structure', 'effect'].every(type => types.includes(type));
            
            if (isSameDrug && hasAllTypes) {
                // 匹配成功
                handleMatchSuccess();
            } else {
                // 匹配失败
                handleMatchFailure();
            }
            
            // 清除选择
            selected.forEach(card => {
                card.isSelected = false;
            });
            gameState.selectedCards = [];
        }
        
        // 处理匹配成功
        function handleMatchSuccess() {
            const selected = gameState.selectedCards;
            const drug = DRUG_DATA[selected[0].drugId];
            
            // 增加连击
            gameState.combo++;
            
            // 计算得分
            const baseScore = 100;
            const comboMultiplier = GAME_CONFIG.comboBonus[Math.min(gameState.combo - 1, GAME_CONFIG.comboBonus.length - 1)];
            const scoreGain = Math.floor(baseScore * comboMultiplier);
            gameState.score += scoreGain;
            
            // 标记卡片为已匹配
            selected.forEach(card => {
                card.isMatched = true;
                card.isVisible = false;
                createParticleEffect(card.x + card.width/2, card.y + card.height/2);
            });
            
            // 显示连击效果
            if (gameState.combo > 1) {
                showComboEffect();
            }
            
            // 播放成功音效
            playSound('match');
            
            // 检查游戏是否完成
            checkGameCompletion();
            
            // 更新UI
            updateUI();
        }
        
        // 处理匹配失败
        function handleMatchFailure() {
            // 重置连击
            gameState.combo = 0;
            
            // 播放失败音效
            playSound('fail');
            
            // 显示失败动画
            gameState.selectedCards.forEach(card => {
                anime({
                    targets: card,
                    animationOffset: [0, 10, -10, 0],
                    duration: 500,
                    easing: 'easeInOutQuad'
                });
            });
            
            updateUI();
        }
        
        // 显示连击效果
        function showComboEffect() {
            const comboDisplay = document.getElementById('comboDisplay');
            comboDisplay.textContent = `${gameState.combo}连击!`;
            comboDisplay.style.opacity = '1';
            
            anime({
                targets: comboDisplay,
                scale: [0.5, 1.2, 1],
                opacity: [0, 1, 0],
                duration: 1500,
                easing: 'easeOutElastic(1, .8)'
            });
        }
        
        // 创建粒子效果
        function createParticleEffect(x, y) {
            const container = document.getElementById('particleContainer');
            const particleCount = 20;
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.style.position = 'absolute';
                particle.style.width = '4px';
                particle.style.height = '4px';
                particle.style.backgroundColor = `hsl(${Math.random() * 60 + 160}, 70%, 60%)`;
                particle.style.borderRadius = '50%';
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                particle.style.pointerEvents = 'none';
                
                container.appendChild(particle);
                
                anime({
                    targets: particle,
                    translateX: (Math.random() - 0.5) * 200,
                    translateY: (Math.random() - 0.5) * 200,
                    opacity: [1, 0],
                    scale: [1, 0],
                    duration: 1000,
                    easing: 'easeOutQuad',
                    complete: () => {
                        container.removeChild(particle);
                    }
                });
            }
        }
        
        // 使用提示
        function useHint() {
            if (gameState.score < GAME_CONFIG.hintCost || gameState.hints <= 0) {
                playSound('error');
                return;
            }
            
            gameState.score -= GAME_CONFIG.hintCost;
            gameState.hints--;
            
            // 找到一个未完成的药物组合
            const unmatchedDrug = DRUG_DATA.find((drug, index) => {
                return !gameState.cards.some(card => card.drugId === index && card.isMatched);
            });
            
            if (unmatchedDrug) {
                const drugCards = gameState.cards.filter(card => 
                    card.drugId === DRUG_DATA.indexOf(unmatchedDrug) && card.isVisible
                );
                
                // 高亮显示相关卡片
                drugCards.forEach(card => {
                    card.isHighlighted = true;
                    setTimeout(() => {
                        card.isHighlighted = false;
                    }, 2000);
                });
            }
            
            playSound('hint');
            updateUI();
        }
        
        // 开始游戏循环
        function startGameLoop() {
            function gameLoop() {
                if (!gameState.isPaused && !gameState.isGameOver) {
                    update();
                    render();
                }
                animationId = requestAnimationFrame(gameLoop);
            }
            gameLoop();
        }
        
        // 更新游戏状态
        function update() {
            // 更新卡片动画
            gameState.cards.forEach(card => {
                if (card.animationOffset !== 0) {
                    card.animationOffset *= 0.9; // 逐渐减小动画偏移
                }
            });
        }
        
        // 渲染游戏画面
        function render() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制背景
            drawBackground();
            
            // 绘制连线
            drawConnections();
            
            // 绘制卡片
            drawCards();
            
            // 绘制选中效果
            drawSelectionEffects();
        }
        
        // 绘制背景
        function drawBackground() {
            // 创建渐变背景
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, 'rgba(26, 54, 93, 0.8)');
            gradient.addColorStop(0.5, 'rgba(45, 55, 72, 0.8)');
            gradient.addColorStop(1, 'rgba(26, 32, 44, 0.8)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制网格线
            ctx.strokeStyle = 'rgba(56, 178, 172, 0.1)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= GAME_CONFIG.cols; i++) {
                const x = (canvas.width - (GAME_CONFIG.cols * (GAME_CONFIG.cardWidth + GAME_CONFIG.cardMargin) - GAME_CONFIG.cardMargin)) / 2 + i * (GAME_CONFIG.cardWidth + GAME_CONFIG.cardMargin);
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let i = 0; i <= GAME_CONFIG.rows; i++) {
                const y = (canvas.height - (GAME_CONFIG.rows * (GAME_CONFIG.cardHeight + GAME_CONFIG.cardMargin) - GAME_CONFIG.cardMargin)) / 2 + i * (GAME_CONFIG.cardHeight + GAME_CONFIG.cardMargin);
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        // 绘制卡片
        function drawCards() {
            gameState.cards.forEach(card => {
                if (!card.isVisible) return;
                
                const x = card.x;
                const y = card.y + card.animationOffset;
                const width = card.width;
                const height = card.height;
                
                // 卡片背景
                let bgColor = 'rgba(255, 255, 255, 0.9)';
                if (card.isSelected) {
                    bgColor = 'rgba(56, 178, 172, 0.9)';
                } else if (card.isHighlighted) {
                    bgColor = 'rgba(246, 173, 85, 0.9)';
                } else if (card.isMatched) {
                    bgColor = 'rgba(56, 178, 172, 0.3)';
                }
                
                // 绘制卡片背景
                ctx.fillStyle = bgColor;
                ctx.fillRect(x, y, width, height);
                
                // 绘制卡片边框
                ctx.strokeStyle = card.isSelected ? '#38b2ac' : '#e2e8f0';
                ctx.lineWidth = card.isSelected ? 3 : 1;
                ctx.strokeRect(x, y, width, height);
                
                // 绘制卡片内容
                ctx.fillStyle = '#2d3748';
                ctx.font = 'bold 14px "Noto Sans SC"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // 根据卡片类型显示不同内容
                let displayText = card.content;
                if (card.type === 'structure') {
                    ctx.font = '12px "Noto Sans SC"';
                }
                
                // 文本换行处理
                const maxWidth = width - 20;
                const words = displayText.split('');
                let line = '';
                let yPos = y + height / 2 - 10;
                
                for (let i = 0; i < words.length; i++) {
                    const testLine = line + words[i];
                    const metrics = ctx.measureText(testLine);
                    
                    if (metrics.width > maxWidth && i > 0) {
                        ctx.fillText(line, x + width / 2, yPos);
                        line = words[i];
                        yPos += 20;
                    } else {
                        line = testLine;
                    }
                }
                ctx.fillText(line, x + width / 2, yPos);
                
                // 绘制卡片类型标识
                ctx.font = '10px "Noto Sans SC"';
                ctx.fillStyle = '#718096';
                const typeText = {
                    'name': '名称',
                    'source': '来源',
                    'structure': '结构',
                    'effect': '功效'
                }[card.type];
                ctx.fillText(typeText, x + width / 2, y + height - 15);
            });
        }
        
        // 绘制连线
        function drawConnections() {
            if (gameState.selectedCards.length < 2) return;
            
            ctx.strokeStyle = '#38b2ac';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            
            for (let i = 0; i < gameState.selectedCards.length - 1; i++) {
                const card1 = gameState.selectedCards[i];
                const card2 = gameState.selectedCards[i + 1];
                
                ctx.beginPath();
                ctx.moveTo(card1.x + card1.width / 2, card1.y + card1.height / 2);
                ctx.lineTo(card2.x + card2.width / 2, card2.y + card2.height / 2);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
        }
        
        // 绘制选中效果
        function drawSelectionEffects() {
            gameState.selectedCards.forEach((card, index) => {
                // 绘制选中序号
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px "Noto Sans SC"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText((index + 1).toString(), card.x + card.width - 15, card.y + 15);
            });
        }
        
        // 开始计时器
        function startTimer() {
            timerInterval = setInterval(() => {
                if (!gameState.isPaused && !gameState.isGameOver) {
                    gameState.timeLeft--;
                    updateUI();
                    
                    if (gameState.timeLeft <= 0) {
                        endGame();
                    }
                }
            }, 1000);
        }
        
        // 更新UI
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('timer').textContent = gameState.timeLeft;
            
            // 更新进度条
            const totalCards = gameState.cards.length;
            const matchedCards = gameState.cards.filter(card => card.isMatched).length;
            const progress = (matchedCards / totalCards) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
            
            // 更新提示按钮状态
            const hintBtn = document.getElementById('hintBtn');
            if (gameState.score < GAME_CONFIG.hintCost || gameState.hints <= 0) {
                hintBtn.style.opacity = '0.5';
                hintBtn.style.cursor = 'not-allowed';
            } else {
                hintBtn.style.opacity = '1';
                hintBtn.style.cursor = 'pointer';
            }
        }
        
        // 检查游戏完成
        function checkGameCompletion() {
            const allMatched = gameState.cards.every(card => card.isMatched);
            if (allMatched) {
                // 进入下一关
                nextLevel();
            }
        }
        
        // 下一关
        function nextLevel() {
            gameState.level++;
            gameState.timeLeft = GAME_CONFIG.levelTime;
            gameState.combo = 0;
            
            // 重新初始化卡片
            initCards();
            
            // 播放升级音效
            playSound('levelup');
            
            updateUI();
        }
        
        // 切换暂停
        function togglePause() {
            gameState.isPaused = !gameState.isPaused;
            
            const overlay = document.getElementById('gameOverlay');
            const pauseBtn = document.getElementById('pauseBtn');
            
            if (gameState.isPaused) {
                overlay.style.display = 'flex';
                pauseBtn.innerHTML = '▶️ 继续';
            } else {
                overlay.style.display = 'none';
                pauseBtn.innerHTML = '⏸️ 暂停';
            }
        }
        
        // 重新开始游戏
        function restartGame() {
            // 重置游戏状态
            gameState = {
                score: 0,
                level: 1,
                timeLeft: GAME_CONFIG.levelTime,
                isPaused: false,
                isGameOver: false,
                selectedCards: [],
                matchedPairs: [],
                combo: 0,
                hints: 3,
                cards: [],
                connections: []
            };
            
            // 清除计时器
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            // 重新初始化
            initCards();
            startTimer();
            updateUI();
            
            // 隐藏暂停菜单
            document.getElementById('gameOverlay').style.display = 'none';
            gameState.isPaused = false;
        }
        
        // 结束游戏
        function endGame() {
            gameState.isGameOver = true;
            clearInterval(timerInterval);
            
            // 保存游戏数据到本地存储
            const gameResult = {
                score: gameState.score,
                level: gameState.level,
                timeUsed: GAME_CONFIG.levelTime - gameState.timeLeft,
                date: new Date().toISOString()
            };
            
            localStorage.setItem('gameResult', JSON.stringify(gameResult));
            
            // 跳转到结束页面
            window.location.href = 'end.html';
        }
        
        // 返回主页
        function backToHome() {
            if (confirm('确定要返回主页吗？当前游戏进度将丢失。')) {
                window.location.href = 'index.html';
            }
        }
        
        // 播放音效
        function playSound(type) {
            // 这里可以添加音效播放逻辑
            // 由于浏览器限制，实际项目中需要用户交互后才能播放音频
        }
        
        // 工具函数：打乱数组
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        // 页面加载完成后初始化游戏
        document.addEventListener('DOMContentLoaded', () => {
            initGame();
        });
        
        // 页面卸载时清理资源
        window.addEventListener('beforeunload', () => {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        });
    </script>
</body>
</html>