<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æµ·æ´‹è¯ç‰©è¿è¿çœ‹ - æ¸¸æˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&family=Noto+Serif+SC:wght@400;700&family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans SC', sans-serif;
            background: linear-gradient(135deg, #1a365d 0%, #2d3748 50%, #1a202c 100%);
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        .game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .game-header {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            z-index: 100;
        }
        
        .game-board {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: pointer;
        }
        
        .score-display {
            font-size: 1.5rem;
            font-weight: bold;
            color: #38b2ac;
        }
        
        .timer-display {
            font-size: 1.2rem;
            color: #ed8936;
        }
        
        .level-display {
            font-size: 1.1rem;
            color: #f6ad55;
        }
        
        .control-btn {
            background: linear-gradient(45deg, #38b2ac, #319795);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 0 0.5rem;
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(56, 178, 172, 0.4);
        }
        
        .pause-btn {
            background: linear-gradient(45deg, #ed8936, #f6ad55);
        }
        
        .pause-btn:hover {
            box-shadow: 0 5px 15px rgba(237, 137, 54, 0.4);
        }
        
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        .pause-menu {
            background: white;
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }
        
        .combo-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #38b2ac;
            pointer-events: none;
            z-index: 150;
            opacity: 0;
        }
        
        .particle-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }
        
        .hint-btn {
            background: linear-gradient(45deg, #805ad5, #9f7aea);
        }
        
        .hint-btn:hover {
            box-shadow: 0 5px 15px rgba(128, 90, 213, 0.4);
        }
        
        .progress-bar {
            width: 200px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #38b2ac, #f6ad55);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- æ¸¸æˆå¤´éƒ¨ -->
        <div class="game-header">
            <div class="flex items-center space-x-6">
                <div class="score-display">
                    <span class="text-sm">å¾—åˆ†:</span>
                    <span id="score">0</span>
                </div>
                <div class="level-display">
                    <span class="text-sm">å…³å¡:</span>
                    <span id="level">1</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            
            <div class="flex items-center space-x-4">
                <div class="timer-display">
                    <span class="text-sm">æ—¶é—´:</span>
                    <span id="timer">180</span>s
                </div>
                <button class="control-btn hint-btn" onclick="useHint()" id="hintBtn">
                    ğŸ’¡ æç¤º
                </button>
                <button class="control-btn pause-btn" onclick="togglePause()" id="pauseBtn">
                    â¸ï¸ æš‚åœ
                </button>
                <button class="control-btn" onclick="restartGame()">
                    ğŸ”„ é‡å¼€
                </button>
                <button class="control-btn" onclick="backToHome()">
                    ğŸ  ä¸»é¡µ
                </button>
            </div>
        </div>
        
        <!-- æ¸¸æˆåŒºåŸŸ -->
        <div class="game-board">
            <canvas id="gameCanvas"></canvas>
            
            <!-- ç²’å­æ•ˆæœå®¹å™¨ -->
            <div class="particle-container" id="particleContainer"></div>
            
            <!-- è¿å‡»æ˜¾ç¤º -->
            <div class="combo-display" id="comboDisplay">Perfect!</div>
            
            <!-- æ¸¸æˆæš‚åœèœå• -->
            <div class="game-overlay" id="gameOverlay">
                <div class="pause-menu">
                    <h2 class="text-3xl font-bold text-gray-800 mb-6">æ¸¸æˆæš‚åœ</h2>
                    <div class="space-y-4">
                        <button class="control-btn w-full" onclick="togglePause()">
                            â–¶ï¸ ç»§ç»­æ¸¸æˆ
                        </button>
                        <button class="control-btn w-full" onclick="restartGame()">
                            ğŸ”„ é‡æ–°å¼€å§‹
                        </button>
                        <button class="control-btn w-full" onclick="backToHome()">
                            ğŸ  è¿”å›ä¸»é¡µ
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // æ¸¸æˆé…ç½®
        const GAME_CONFIG = {
            cardWidth: 120,
            cardHeight: 80,
            cardMargin: 15,
            cols: 8,
            rows: 6,
            levelTime: 180, // 3åˆ†é’Ÿ
            hintCost: 50, // æç¤ºæ¶ˆè€—åˆ†æ•°
            comboBonus: [1, 1.2, 1.5, 2, 2.5, 3] // è¿å‡»åŠ æˆ
        };
        
        // æµ·æ´‹è¯ç‰©æ•°æ®
        const DRUG_DATA = [
            {
                name: "æ²³è±šæ¯’ç´ ",
                source: "æ²³è±šé±¼åµå·¢",
                structure: "C11H17N3O8",
                effect: "ç¥ç»é•‡ç—›",
                description: "å¼ºæ•ˆçš„ç¥ç»æ¯’ç´ ï¼Œå…·æœ‰æŠ—ç™Œå’Œæˆ’æ¯’ä½œç”¨"
            },
            {
                name: "çŸ³æˆ¿è›¤æ¯’ç´ ",
                source: "èµ¤æ½®åŒé­æ¯›è—»",
                structure: "C10H17N7O4",
                effect: "æŠ—ç™Œç ”ç©¶",
                description: "ç¥ç»æ¯’ç´ ï¼Œç”¨äºæŠ—ç™Œè¯ç‰©ç ”ç©¶"
            },
            {
                name: "æ²™æµ·è‘µæ¯’ç´ ",
                source: "æµ·è‘µP.toxica",
                structure: "C129H223N3O54",
                effect: "æŠ—è‚¿ç˜¤",
                description: "æœ€å¼ºçš„å† çŠ¶åŠ¨è„‰æ”¶ç¼©å‰‚ä¹‹ä¸€"
            },
            {
                name: "è¥¿åŠ æ¯’ç´ ",
                source: "å²—æ¯”ç”²è—»",
                structure: "C60H80O19",
                effect: "ç¥ç»ç ”ç©¶",
                description: "çƒ­å¸¦é±¼ç±»æ¯’ç´ ï¼Œç¥ç»ç§‘å­¦ç ”ç©¶"
            },
            {
                name: "å¤´å­¢èŒç´ C",
                source: "æµ·æ´‹çœŸèŒ",
                structure: "C16H21N3O8S",
                effect: "æŠ—èŒæ¶ˆç‚",
                description: "å¹¿è°±æŠ—ç”Ÿç´ ï¼ŒæŠ—èŒä½œç”¨å¼º"
            },
            {
                name: "è—»é…¸åŒé…¯é’ ",
                source: "è¤è—»æå–ç‰©",
                structure: "C6H9NaO7",
                effect: "æŠ—å‡è¡€",
                description: "å¿ƒè„‘è¡€ç®¡ç–¾ç—…é˜²æ²»è¯ç‰©"
            }
        ];
        
        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            score: 0,
            level: 1,
            timeLeft: GAME_CONFIG.levelTime,
            isPaused: false,
            isGameOver: false,
            selectedCards: [],
            matchedPairs: [],
            combo: 0,
            hints: 3,
            cards: [],
            connections: []
        };
        
        // Canvaså’Œæ¸¸æˆä¸Šä¸‹æ–‡
        let canvas, ctx;
        let animationId;
        let timerInterval;
        
        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // è®¾ç½®Canvaså°ºå¯¸
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // åˆå§‹åŒ–å¡ç‰‡
            initCards();
            
            // è®¾ç½®äº‹ä»¶ç›‘å¬
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            
            // å¼€å§‹æ¸¸æˆå¾ªç¯
            startGameLoop();
            
            // å¼€å§‹è®¡æ—¶
            startTimer();
            
            // æ›´æ–°UI
            updateUI();
        }
        
        // è°ƒæ•´Canvaså°ºå¯¸
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            // é‡æ–°è®¡ç®—å¡ç‰‡ä½ç½®
            if (gameState.cards.length > 0) {
                calculateCardPositions();
            }
        }
        
        // åˆå§‹åŒ–å¡ç‰‡
        function initCards() {
            gameState.cards = [];
            
            // ä¸ºæ¯ç§è¯ç‰©åˆ›å»º4å¼ å¡ç‰‡ï¼ˆåç§°ã€æ¥æºã€ç»“æ„ã€åŠŸæ•ˆï¼‰
            DRUG_DATA.forEach((drug, drugIndex) => {
                const cards = [
                    { type: 'name', content: drug.name, drugId: drugIndex, id: `name_${drugIndex}` },
                    { type: 'source', content: drug.source, drugId: drugIndex, id: `source_${drugIndex}` },
                    { type: 'structure', content: drug.structure, drugId: drugIndex, id: `structure_${drugIndex}` },
                    { type: 'effect', content: drug.effect, drugId: drugIndex, id: `effect_${drugIndex}` }
                ];
                gameState.cards.push(...cards);
            });
            
            // éšæœºæ‰“ä¹±å¡ç‰‡
            shuffleArray(gameState.cards);
            
            // è®¡ç®—å¡ç‰‡ä½ç½®
            calculateCardPositions();
        }
        
        // è®¡ç®—å¡ç‰‡ä½ç½®
        function calculateCardPositions() {
            const startX = (canvas.width - (GAME_CONFIG.cols * (GAME_CONFIG.cardWidth + GAME_CONFIG.cardMargin) - GAME_CONFIG.cardMargin)) / 2;
            const startY = (canvas.height - (GAME_CONFIG.rows * (GAME_CONFIG.cardHeight + GAME_CONFIG.cardMargin) - GAME_CONFIG.cardMargin)) / 2;
            
            gameState.cards.forEach((card, index) => {
                const col = index % GAME_CONFIG.cols;
                const row = Math.floor(index / GAME_CONFIG.cols);
                
                card.x = startX + col * (GAME_CONFIG.cardWidth + GAME_CONFIG.cardMargin);
                card.y = startY + row * (GAME_CONFIG.cardHeight + GAME_CONFIG.cardMargin);
                card.width = GAME_CONFIG.cardWidth;
                card.height = GAME_CONFIG.cardHeight;
                card.isVisible = true;
                card.isSelected = false;
                card.isMatched = false;
                card.animationOffset = 0;
            });
        }
        
        // å¤„ç†Canvasç‚¹å‡»äº‹ä»¶
        function handleCanvasClick(event) {
            if (gameState.isPaused || gameState.isGameOver) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // æŸ¥æ‰¾ç‚¹å‡»çš„å¡ç‰‡
            const clickedCard = gameState.cards.find(card => 
                card.isVisible && 
                x >= card.x && x <= card.x + card.width &&
                y >= card.y && y <= card.y + card.height
            );
            
            if (clickedCard && !clickedCard.isMatched) {
                selectCard(clickedCard);
            }
        }
        
        // å¤„ç†Canvasé¼ æ ‡ç§»åŠ¨
        function handleCanvasMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // æ£€æŸ¥æ˜¯å¦æ‚¬åœåœ¨å¡ç‰‡ä¸Š
            const hoveredCard = gameState.cards.find(card => 
                card.isVisible && 
                x >= card.x && x <= card.x + card.width &&
                y >= card.y && y <= card.y + card.height
            );
            
            canvas.style.cursor = hoveredCard && !hoveredCard.isMatched ? 'pointer' : 'default';
        }
        
        // é€‰æ‹©å¡ç‰‡
        function selectCard(card) {
            if (gameState.selectedCards.includes(card)) {
                // å–æ¶ˆé€‰æ‹©
                card.isSelected = false;
                gameState.selectedCards = gameState.selectedCards.filter(c => c !== card);
            } else if (gameState.selectedCards.length < 4) {
                // é€‰æ‹©å¡ç‰‡
                card.isSelected = true;
                gameState.selectedCards.push(card);
                
                // æ’­æ”¾é€‰æ‹©éŸ³æ•ˆ
                playSound('select');
                
                // æ£€æŸ¥æ˜¯å¦é€‰æ‹©äº†4å¼ å¡ç‰‡
                if (gameState.selectedCards.length === 4) {
                    setTimeout(() => checkMatch(), 300);
                }
            }
        }
        
        // æ£€æŸ¥åŒ¹é…
        function checkMatch() {
            const selected = gameState.selectedCards;
            
            // æ£€æŸ¥æ˜¯å¦æ¥è‡ªåŒä¸€ç§è¯ç‰©
            const drugIds = selected.map(card => card.drugId);
            const isSameDrug = drugIds.every(id => id === drugIds[0]);
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«æ‰€æœ‰4ç§ç±»å‹
            const types = selected.map(card => card.type);
            const hasAllTypes = ['name', 'source', 'structure', 'effect'].every(type => types.includes(type));
            
            if (isSameDrug && hasAllTypes) {
                // åŒ¹é…æˆåŠŸ
                handleMatchSuccess();
            } else {
                // åŒ¹é…å¤±è´¥
                handleMatchFailure();
            }
            
            // æ¸…é™¤é€‰æ‹©
            selected.forEach(card => {
                card.isSelected = false;
            });
            gameState.selectedCards = [];
        }
        
        // å¤„ç†åŒ¹é…æˆåŠŸ
        function handleMatchSuccess() {
            const selected = gameState.selectedCards;
            const drug = DRUG_DATA[selected[0].drugId];
            
            // å¢åŠ è¿å‡»
            gameState.combo++;
            
            // è®¡ç®—å¾—åˆ†
            const baseScore = 100;
            const comboMultiplier = GAME_CONFIG.comboBonus[Math.min(gameState.combo - 1, GAME_CONFIG.comboBonus.length - 1)];
            const scoreGain = Math.floor(baseScore * comboMultiplier);
            gameState.score += scoreGain;
            
            // æ ‡è®°å¡ç‰‡ä¸ºå·²åŒ¹é…
            selected.forEach(card => {
                card.isMatched = true;
                card.isVisible = false;
                createParticleEffect(card.x + card.width/2, card.y + card.height/2);
            });
            
            // æ˜¾ç¤ºè¿å‡»æ•ˆæœ
            if (gameState.combo > 1) {
                showComboEffect();
            }
            
            // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
            playSound('match');
            
            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦å®Œæˆ
            checkGameCompletion();
            
            // æ›´æ–°UI
            updateUI();
        }
        
        // å¤„ç†åŒ¹é…å¤±è´¥
        function handleMatchFailure() {
            // é‡ç½®è¿å‡»
            gameState.combo = 0;
            
            // æ’­æ”¾å¤±è´¥éŸ³æ•ˆ
            playSound('fail');
            
            // æ˜¾ç¤ºå¤±è´¥åŠ¨ç”»
            gameState.selectedCards.forEach(card => {
                anime({
                    targets: card,
                    animationOffset: [0, 10, -10, 0],
                    duration: 500,
                    easing: 'easeInOutQuad'
                });
            });
            
            updateUI();
        }
        
        // æ˜¾ç¤ºè¿å‡»æ•ˆæœ
        function showComboEffect() {
            const comboDisplay = document.getElementById('comboDisplay');
            comboDisplay.textContent = `${gameState.combo}è¿å‡»!`;
            comboDisplay.style.opacity = '1';
            
            anime({
                targets: comboDisplay,
                scale: [0.5, 1.2, 1],
                opacity: [0, 1, 0],
                duration: 1500,
                easing: 'easeOutElastic(1, .8)'
            });
        }
        
        // åˆ›å»ºç²’å­æ•ˆæœ
        function createParticleEffect(x, y) {
            const container = document.getElementById('particleContainer');
            const particleCount = 20;
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.style.position = 'absolute';
                particle.style.width = '4px';
                particle.style.height = '4px';
                particle.style.backgroundColor = `hsl(${Math.random() * 60 + 160}, 70%, 60%)`;
                particle.style.borderRadius = '50%';
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                particle.style.pointerEvents = 'none';
                
                container.appendChild(particle);
                
                anime({
                    targets: particle,
                    translateX: (Math.random() - 0.5) * 200,
                    translateY: (Math.random() - 0.5) * 200,
                    opacity: [1, 0],
                    scale: [1, 0],
                    duration: 1000,
                    easing: 'easeOutQuad',
                    complete: () => {
                        container.removeChild(particle);
                    }
                });
            }
        }
        
        // ä½¿ç”¨æç¤º
        function useHint() {
            if (gameState.score < GAME_CONFIG.hintCost || gameState.hints <= 0) {
                playSound('error');
                return;
            }
            
            gameState.score -= GAME_CONFIG.hintCost;
            gameState.hints--;
            
            // æ‰¾åˆ°ä¸€ä¸ªæœªå®Œæˆçš„è¯ç‰©ç»„åˆ
            const unmatchedDrug = DRUG_DATA.find((drug, index) => {
                return !gameState.cards.some(card => card.drugId === index && card.isMatched);
            });
            
            if (unmatchedDrug) {
                const drugCards = gameState.cards.filter(card => 
                    card.drugId === DRUG_DATA.indexOf(unmatchedDrug) && card.isVisible
                );
                
                // é«˜äº®æ˜¾ç¤ºç›¸å…³å¡ç‰‡
                drugCards.forEach(card => {
                    card.isHighlighted = true;
                    setTimeout(() => {
                        card.isHighlighted = false;
                    }, 2000);
                });
            }
            
            playSound('hint');
            updateUI();
        }
        
        // å¼€å§‹æ¸¸æˆå¾ªç¯
        function startGameLoop() {
            function gameLoop() {
                if (!gameState.isPaused && !gameState.isGameOver) {
                    update();
                    render();
                }
                animationId = requestAnimationFrame(gameLoop);
            }
            gameLoop();
        }
        
        // æ›´æ–°æ¸¸æˆçŠ¶æ€
        function update() {
            // æ›´æ–°å¡ç‰‡åŠ¨ç”»
            gameState.cards.forEach(card => {
                if (card.animationOffset !== 0) {
                    card.animationOffset *= 0.9; // é€æ¸å‡å°åŠ¨ç”»åç§»
                }
            });
        }
        
        // æ¸²æŸ“æ¸¸æˆç”»é¢
        function render() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶èƒŒæ™¯
            drawBackground();
            
            // ç»˜åˆ¶è¿çº¿
            drawConnections();
            
            // ç»˜åˆ¶å¡ç‰‡
            drawCards();
            
            // ç»˜åˆ¶é€‰ä¸­æ•ˆæœ
            drawSelectionEffects();
        }
        
        // ç»˜åˆ¶èƒŒæ™¯
        function drawBackground() {
            // åˆ›å»ºæ¸å˜èƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, 'rgba(26, 54, 93, 0.8)');
            gradient.addColorStop(0.5, 'rgba(45, 55, 72, 0.8)');
            gradient.addColorStop(1, 'rgba(26, 32, 44, 0.8)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶ç½‘æ ¼çº¿
            ctx.strokeStyle = 'rgba(56, 178, 172, 0.1)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= GAME_CONFIG.cols; i++) {
                const x = (canvas.width - (GAME_CONFIG.cols * (GAME_CONFIG.cardWidth + GAME_CONFIG.cardMargin) - GAME_CONFIG.cardMargin)) / 2 + i * (GAME_CONFIG.cardWidth + GAME_CONFIG.cardMargin);
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let i = 0; i <= GAME_CONFIG.rows; i++) {
                const y = (canvas.height - (GAME_CONFIG.rows * (GAME_CONFIG.cardHeight + GAME_CONFIG.cardMargin) - GAME_CONFIG.cardMargin)) / 2 + i * (GAME_CONFIG.cardHeight + GAME_CONFIG.cardMargin);
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        // ç»˜åˆ¶å¡ç‰‡
        function drawCards() {
            gameState.cards.forEach(card => {
                if (!card.isVisible) return;
                
                const x = card.x;
                const y = card.y + card.animationOffset;
                const width = card.width;
                const height = card.height;
                
                // å¡ç‰‡èƒŒæ™¯
                let bgColor = 'rgba(255, 255, 255, 0.9)';
                if (card.isSelected) {
                    bgColor = 'rgba(56, 178, 172, 0.9)';
                } else if (card.isHighlighted) {
                    bgColor = 'rgba(246, 173, 85, 0.9)';
                } else if (card.isMatched) {
                    bgColor = 'rgba(56, 178, 172, 0.3)';
                }
                
                // ç»˜åˆ¶å¡ç‰‡èƒŒæ™¯
                ctx.fillStyle = bgColor;
                ctx.fillRect(x, y, width, height);
                
                // ç»˜åˆ¶å¡ç‰‡è¾¹æ¡†
                ctx.strokeStyle = card.isSelected ? '#38b2ac' : '#e2e8f0';
                ctx.lineWidth = card.isSelected ? 3 : 1;
                ctx.strokeRect(x, y, width, height);
                
                // ç»˜åˆ¶å¡ç‰‡å†…å®¹
                ctx.fillStyle = '#2d3748';
                ctx.font = 'bold 14px "Noto Sans SC"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // æ ¹æ®å¡ç‰‡ç±»å‹æ˜¾ç¤ºä¸åŒå†…å®¹
                let displayText = card.content;
                if (card.type === 'structure') {
                    ctx.font = '12px "Noto Sans SC"';
                }
                
                // æ–‡æœ¬æ¢è¡Œå¤„ç†
                const maxWidth = width - 20;
                const words = displayText.split('');
                let line = '';
                let yPos = y + height / 2 - 10;
                
                for (let i = 0; i < words.length; i++) {
                    const testLine = line + words[i];
                    const metrics = ctx.measureText(testLine);
                    
                    if (metrics.width > maxWidth && i > 0) {
                        ctx.fillText(line, x + width / 2, yPos);
                        line = words[i];
                        yPos += 20;
                    } else {
                        line = testLine;
                    }
                }
                ctx.fillText(line, x + width / 2, yPos);
                
                // ç»˜åˆ¶å¡ç‰‡ç±»å‹æ ‡è¯†
                ctx.font = '10px "Noto Sans SC"';
                ctx.fillStyle = '#718096';
                const typeText = {
                    'name': 'åç§°',
                    'source': 'æ¥æº',
                    'structure': 'ç»“æ„',
                    'effect': 'åŠŸæ•ˆ'
                }[card.type];
                ctx.fillText(typeText, x + width / 2, y + height - 15);
            });
        }
        
        // ç»˜åˆ¶è¿çº¿
        function drawConnections() {
            if (gameState.selectedCards.length < 2) return;
            
            ctx.strokeStyle = '#38b2ac';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            
            for (let i = 0; i < gameState.selectedCards.length - 1; i++) {
                const card1 = gameState.selectedCards[i];
                const card2 = gameState.selectedCards[i + 1];
                
                ctx.beginPath();
                ctx.moveTo(card1.x + card1.width / 2, card1.y + card1.height / 2);
                ctx.lineTo(card2.x + card2.width / 2, card2.y + card2.height / 2);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
        }
        
        // ç»˜åˆ¶é€‰ä¸­æ•ˆæœ
        function drawSelectionEffects() {
            gameState.selectedCards.forEach((card, index) => {
                // ç»˜åˆ¶é€‰ä¸­åºå·
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px "Noto Sans SC"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText((index + 1).toString(), card.x + card.width - 15, card.y + 15);
            });
        }
        
        // å¼€å§‹è®¡æ—¶å™¨
        function startTimer() {
            timerInterval = setInterval(() => {
                if (!gameState.isPaused && !gameState.isGameOver) {
                    gameState.timeLeft--;
                    updateUI();
                    
                    if (gameState.timeLeft <= 0) {
                        endGame();
                    }
                }
            }, 1000);
        }
        
        // æ›´æ–°UI
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('timer').textContent = gameState.timeLeft;
            
            // æ›´æ–°è¿›åº¦æ¡
            const totalCards = gameState.cards.length;
            const matchedCards = gameState.cards.filter(card => card.isMatched).length;
            const progress = (matchedCards / totalCards) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
            
            // æ›´æ–°æç¤ºæŒ‰é’®çŠ¶æ€
            const hintBtn = document.getElementById('hintBtn');
            if (gameState.score < GAME_CONFIG.hintCost || gameState.hints <= 0) {
                hintBtn.style.opacity = '0.5';
                hintBtn.style.cursor = 'not-allowed';
            } else {
                hintBtn.style.opacity = '1';
                hintBtn.style.cursor = 'pointer';
            }
        }
        
        // æ£€æŸ¥æ¸¸æˆå®Œæˆ
        function checkGameCompletion() {
            const allMatched = gameState.cards.every(card => card.isMatched);
            if (allMatched) {
                // è¿›å…¥ä¸‹ä¸€å…³
                nextLevel();
            }
        }
        
        // ä¸‹ä¸€å…³
        function nextLevel() {
            gameState.level++;
            gameState.timeLeft = GAME_CONFIG.levelTime;
            gameState.combo = 0;
            
            // é‡æ–°åˆå§‹åŒ–å¡ç‰‡
            initCards();
            
            // æ’­æ”¾å‡çº§éŸ³æ•ˆ
            playSound('levelup');
            
            updateUI();
        }
        
        // åˆ‡æ¢æš‚åœ
        function togglePause() {
            gameState.isPaused = !gameState.isPaused;
            
            const overlay = document.getElementById('gameOverlay');
            const pauseBtn = document.getElementById('pauseBtn');
            
            if (gameState.isPaused) {
                overlay.style.display = 'flex';
                pauseBtn.innerHTML = 'â–¶ï¸ ç»§ç»­';
            } else {
                overlay.style.display = 'none';
                pauseBtn.innerHTML = 'â¸ï¸ æš‚åœ';
            }
        }
        
        // é‡æ–°å¼€å§‹æ¸¸æˆ
        function restartGame() {
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            gameState = {
                score: 0,
                level: 1,
                timeLeft: GAME_CONFIG.levelTime,
                isPaused: false,
                isGameOver: false,
                selectedCards: [],
                matchedPairs: [],
                combo: 0,
                hints: 3,
                cards: [],
                connections: []
            };
            
            // æ¸…é™¤è®¡æ—¶å™¨
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            // é‡æ–°åˆå§‹åŒ–
            initCards();
            startTimer();
            updateUI();
            
            // éšè—æš‚åœèœå•
            document.getElementById('gameOverlay').style.display = 'none';
            gameState.isPaused = false;
        }
        
        // ç»“æŸæ¸¸æˆ
        function endGame() {
            gameState.isGameOver = true;
            clearInterval(timerInterval);
            
            // ä¿å­˜æ¸¸æˆæ•°æ®åˆ°æœ¬åœ°å­˜å‚¨
            const gameResult = {
                score: gameState.score,
                level: gameState.level,
                timeUsed: GAME_CONFIG.levelTime - gameState.timeLeft,
                date: new Date().toISOString()
            };
            
            localStorage.setItem('gameResult', JSON.stringify(gameResult));
            
            // è·³è½¬åˆ°ç»“æŸé¡µé¢
            window.location.href = 'end.html';
        }
        
        // è¿”å›ä¸»é¡µ
        function backToHome() {
            if (confirm('ç¡®å®šè¦è¿”å›ä¸»é¡µå—ï¼Ÿå½“å‰æ¸¸æˆè¿›åº¦å°†ä¸¢å¤±ã€‚')) {
                window.location.href = 'index.html';
            }
        }
        
        // æ’­æ”¾éŸ³æ•ˆ
        function playSound(type) {
            // è¿™é‡Œå¯ä»¥æ·»åŠ éŸ³æ•ˆæ’­æ”¾é€»è¾‘
            // ç”±äºæµè§ˆå™¨é™åˆ¶ï¼Œå®é™…é¡¹ç›®ä¸­éœ€è¦ç”¨æˆ·äº¤äº’åæ‰èƒ½æ’­æ”¾éŸ³é¢‘
        }
        
        // å·¥å…·å‡½æ•°ï¼šæ‰“ä¹±æ•°ç»„
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–æ¸¸æˆ
        document.addEventListener('DOMContentLoaded', () => {
            initGame();
        });
        
        // é¡µé¢å¸è½½æ—¶æ¸…ç†èµ„æº
        window.addEventListener('beforeunload', () => {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        });
    </script>
</body>
</html>